# BookStore - Writing Unit Tests

## What You Learn
   
*   [How to wirte unit-test for your aggregates](#Write-unit-tests-for-aggregates)
*   [How to wirte unit-test for your aggregates](#Write-tests-using-stubs)
*   [How to validate the architecture of your application](#Validate-the-Architecture)

## What you need

*   Understand tutorial [`BookStore - Using a Repository`](README.md)
*   30 minutes
*   JDK 17 (or higher) installed
*   Maven 3.6 (or higher) installed

## General Note

In general, you should write pure unit tests, especially for your aggregates. This ensures 
that your business-tests remain independent of any technology. In addition, you avoid the
anti-pattern `anemic model` and accidentally put business logic into an application- or
domain service. 

Depending on the teams' experience in writing tests, this can be quite challenging. If a team
has written a lot of mock tests in the past, the use of stubs can be helpful in communicating
the benefits of a Ports-And-Adapters architecture.

## Write Unit Tests for Aggregates

For all tests we use the arrange-act-assert pattern because it is simple and forces tests to
focus on independent, individual behaviors. A simple example of unit-tests for our aggregate
`Book` can be found [here](src/test/java/io/jexxa/tutorials/bookstore/domain/book/BookTest.java).

In the following example we show how to validate DomainEvents generated by the domain event.
For this purpose, we add a class `DomainEventRecorder` that subscribes either to a specific
domain event, or to all. The method `subscribe` is provided by [`DomainEventPublisher`](src/main/java/io/jexxa/tutorials/bookstore/domain/DomainEventPublisher.java) which is part
of our domain.

```java
class BookTest { 
    @Test
    void sellLastBook() {
        // Arrange
        var amountInStock = 1;
        var domainEventRecorder = new DomainEventRecorder();
        subscribe(BookSoldOut.class, domainEventRecorder::receive);

        var objectUnderTest = newBook(ANY_BOOK);
        objectUnderTest.addToStock(amountInStock);

        // Act / Assert
        assertDoesNotThrow(objectUnderTest::sell);

        // Assert
        assertEquals(0, objectUnderTest.amountInStock() );
        assertEquals(1, domainEventRecorder.getDomainEvents().size() );
    }

    private static class DomainEventRecorder {
        private final List<BookSoldOut> domainEvents = new ArrayList<>();

        public void receive(BookSoldOut bookSoldOut) {
            domainEvents.add(bookSoldOut);
        }

        List<BookSoldOut> getDomainEvents()  {
            return domainEvents;
        }
    }
}
```

## Write Tests using Stubs

If you want to use the stubs for some reason, you first have to add the following dependency to your tests.

```xml
    <dependency>
      <groupId>io.jexxa.jexxatest</groupId>
      <artifactId>jexxa-test</artifactId>
      <version>5.5.4</version>
      <scope>test</scope>
    </dependency>
```
Writing some tests with Jexxa is quite easy. If you implement your driven adapters using
Jexxa's driven adapter strategies you can use package **jexxa-test**. It automatically
provides stubs so that you do not need any mock framework. Main advantages are:

*   You can focus on domain logic within your tests.
*   You don't need to use mocks which can lead to validating execution steps within the domain core instead of validating the domain specific use cases
*   Your tests are much easier to read and can teach new developers the use cases of your domain.
*   You can write your tests first without considering the infrastructure first.


Following code shows a simple validation of our BookStoreService. The described tests can be found [here](src/test/java/io/jexxa/tutorials/bookstore/applicationservice/BookStoreServiceTest.java).

### Initialize the tests 

As a first step, you initialize your tests by calling `initTest()`: 
*    Initialize JexxaTest before each test 
*    Initialize and request all objects you need for testing and validation 
*    Bootstrap all services as in your main method to ensure the same initial setup as you start your application

```java
class BookStoreServiceTest
{
    private static final ISBN13 ANY_BOOK = createISBN("978-3-86490-387-8");

    private BookStoreService objectUnderTest;       // Object we want to test
    private MessageRecorder  publishedDomainEvents; // Message recorder to validate published DomainEvents
    private BookRepository   bookRepository;        // Repository to validate results in the tests
    
    @BeforeEach
    void initTest()
    {
        // JexxaTest is created for each test. It provides stubs for running your tests so that no
        // mock framework is required. It expects the class name your application!
        JexxaTest jexxaTest = getJexxaTest(BookStore.class);

        // Request the objects needed for our tests
        objectUnderTest       = jexxaTest.getInstanceOfPort(BookStoreService.class);   // 1. We need the object we want to test
        publishedDomainEvents = jexxaTest.getMessageRecorder(DomainEventSender.class); // 2. A recorder for DomainEvents published via DomainEventSender
        bookRepository        = jexxaTest.getRepository(BookRepository.class);         // 3. Repository managing all books

        // Invoke all bootstrapping services from main to ensure same starting point
        jexxaTest.getJexxaMain().bootstrapAnnotation(DomainService.class);
    }

    //...
}
```

### A simple test to add books into stock 
```java
class BookStoreServiceTest 
{
    // ... initialization of tests 
    @Test
    void addBooksToStock()
    {
        var amount = 5;

        //Act
        objectUnderTest.addToStock(ANY_BOOK, amount);

        //Assert
        assertEquals( amount, objectUnderTest.amountInStock(ANY_BOOK) );      // Perform assertion against the object we test
        assertEquals( amount, bookRepository.get(ANY_BOOK).amountInStock() ); // Perform assertion against the repository
        assertTrue( publishedDomainEvents.isEmpty() );                        // Perform assertion against published DomainEvents
    }
    // ... further tests 
}
```

### Test selling last book
```java
class BookStoreServiceTest 
{
   // ... initialization of tests

    @Test
    void sellLastBook() 
    {
        //Arrange
        objectUnderTest.addToStock(ANY_BOOK, 1);

        // Act / Assert
        assertDoesNotThrow(() -> objectUnderTest.sell(ANY_BOOK));
        
        //Assert
        assertEquals( 0 , objectUnderTest.amountInStock(ANY_BOOK) );                        // Perform assertion against the object we test
        assertEquals( 1 , publishedDomainEvents.size() );                                   // Perform assertion against the repository
        assertEquals( bookSoldOut(ANY_BOOK), publishedDomainEvents.getMessage(BookSoldOut.class));  // Perform assertion against published DomainEvents
    }

}
```

## Validate the Architecture


Even with a clear architecture, one can easily violate their rules by accident. So I 
strongly recommend to run some tests to validate the architecture of your application. 
Jexxa simplifies this especially if you use its conventions by providing architectural 
tests based on [ArchUnit](https://www.archunit.org). This ensures that the validation of the
architecture is port of your unit tests. 

Jexxa-test provides following architecture tests that. 
*   [Pattern Language](src/test/java/io/jexxa/tutorials/bookstore/architecture/ArchitectureTest.java) to validate the correct annotation of your application using project [Addend](http://addend.jexxa.io/)
*   [Ports&Adapters Architecture](src/test/java/io/jexxa/tutorials/bookstore/architecture/ArchitectureTest.java) to validates dependencies between packages of your application
*   [Usage of Aggregates](src/test/java/io/jexxa/tutorials/bookstore/architecture/ArchitectureTest.java) to validate that your business logic is not exposed



### Validate Ports and Adapters

To validate the rules of a ports and adapter architecture is quite simple if you follow the conventions of Jexxa. As 
you can see below, you just have to declare the packages including the driven and driving adapter of the application.  

```java
class ArchitectureTest {

    @Test
    void validatePortsAndAdapters()
    {
        portsAndAdapters(BookStore.class)
                // Add all packages providing driven adapter  
                .addDrivenAdapterPackage("persistence")  
                .addDrivenAdapterPackage("messaging")

                // Add all packages providing driving adapter such as  
                // .addDrivingAdapterPackage("messaging")
                
                .validate();
    }
}
```

### Validate the Pattern Language
The following test validates that all classes of your application are annotated. In addition, it validates that all 
`ValueObject` and `DomainObject` classes are implemented as java-records. 

```java
class ArchitectureTest {
    @Test
    void validatePatternLanguage() {
        patternLanguage(BookStore.class).validate();
    }
}
```

### Validate the usage of Aggregates
Aggregates include the business logic and must not leave the application core. In addition, they must only be managed 
by a `Repository`. This leads to some additional rules that can be validated using following test: 

```java
class ArchitectureTest {
    @Test
    void validateAggregateRules()
    {
        aggregateRules(BookStore.class).validate();
    }
}
```
