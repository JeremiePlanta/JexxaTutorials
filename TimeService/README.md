# TimeService - Async Messaging

## What You Learn

*   How to write an application service providing the use cases of your application  
*   How to send current time as an async message     
*   How to receive this async message print it to console 

## What you need

*   Understand tutorial `HelloJexxa` because we explain only new aspects 
*   60 minutes
*   JDK 17  (or higher) installed 
*   Maven 3.6 (or higher) installed
*   A running ActiveMQ instance (at least if you start the application with infrastructure)
*   curl to trigger the application  

## Implement the Application Core

The application core consists of following classes:

*   `TimeApplicationService:` Provides the two use cases of your application. In terms of DDD this is an `ApplicationService`.
*   `TimePublisher:` Allows for publishing current time. In terms of DDD, it is an `InfrastrucureService`, because the implementation requires a specific technology stack and cannot belong to the application core.
*   `MessageDisplay:` Shows a message and is an `InfrastructureService` as well.        

### Declare interfaces for the two infrastructure services

The most important aspect here is that a technology-agnostic application must not use any technology-stack. Therefore,
we must define the following two interface. Interface `TimePublisher` that provides us the possibility to publish the 
time by an arbitrary technology stack.

```java
public interface TimePublisher
{
    void publish(LocalTime localTime);
}
```                 

The second interface `MessageDisplay` provides the possibility to display some messages. 

```java
public interface MessageDisplay
{
    void show(String message);
}
```      
  
### Implement class `TimeApplicationService`

Now, we can implement our `ApplicationService` that provides two very simple use cases: 
*   Publish current time   
*   Receive and display a published time

Since Jexxa only supports implicit constructor injection, we have to declare all required interfaces in the constructor.    

```java
public class TimeApplicationService
{
    private final TimePublisher timePublisher;
    private final MessageDisplay messageDisplay;

    /**
     * Note: Jexxa supports only implicit constructor injection. Therefore, we must
     * declare all required interfaces in the constructor.
     *
     * @param timePublisher required outbound port for this application service
     * @param messageDisplay required outbound port for this application service
     */
    public TimeApplicationService(TimePublisher timePublisher, MessageDisplay messageDisplay)
    {
        this.timePublisher = Objects.requireNonNull(timePublisher);
        this.messageDisplay = Objects.requireNonNull(messageDisplay);
    }

    /**
     * Implement use case 1: publish current time 
     */
    public void publishTime()
    {
        timePublisher.publish(LocalTime.now());
    }


    /**
     * Implement use case 2 : Shows the previously published time.
     * @param localTime the previously published time
     */
    public void displayPublishedTime(LocalTime localTime)
    {
        var messageWithPublishedTime = "New Time was published, time: " + localTime.format(DateTimeFormatter.ISO_TIME);
        messageDisplay.show(messageWithPublishedTime);
    }
}
```                  

## Implement the Infrastructure

### Driven Adapter with console output
The interface `MessageDisplay` is implemented by `MessageDisplayImpl` by just printing given arguments to a logger.  

Note: Jexxa uses implicit constructor injection together with a strict convention over configuration approach.

Therefore, each driven adapter needs one of the following constructors: 

*   A public default constructor: `MessageDisplay()`
*   A public constructor with a single `Properties` attribute:  `MessageDisplay(Properties properties)`
*   A public static factory method that gets no parameters and returns the interface which is the type of the driving adapter: `public static MessageDisplay create()`
*   A public static factory method with a single `Properties` parameter and returns the interface which is the type of the requested driving adapter: `public static MessageDisplay create(Properties properties)`
   
Since our driven adapter does not need/support any configuration parameter, we can use default constructor generated by Java.

```java
public class MessageDisplayImpl implements MessageDisplay
{
    @Override
    public void show(String message)
    {
        JexxaLogger.getLogger(MessageDisplay.class).info(message);
    }
}
```

### Driven Adapter for messaging ###

Jexxa provides so called `DrivenAdapterStrategy` for various Java-APIs such as JMS. When using these strategies the 
implementation of a driven adapter is just a facade and maps domain specific methods to the technology stack. In the 
main application we can adjust the default strategy so that we can define either to use JMS or a simple logger. 
Moreover, within tests, we can define a MessageRecorder and unit-test our infrastructure as well.  

Note: Since `TimePublisher` requires information from a `Properties` we must provide a constructor or static factory 
method with a `Properties` attribute. By default, Jexxa hands in all information from jexxa-application.properties file.
This file can be extended by application specific information such as the topic name if required.

In this example, sending a time is just a representation for any kind of measuring point. In real world applications 
this kind of information has no additional semantic meaning. Typically, it is also send in a fixed interval. So, we 
just have to define a notation to publish this information. The following code shows how to publish a LocalTime in 
JSON format.                

```java
@SuppressWarnings("unused")
public class TimePublisherImpl implements TimePublisher
{
    public static final String TIME_TOPIC = "TimeService";

    private final MessageSender messageSender;

    // For all driven adapter we have to provide either a static factory or a public constructor to
    // enable implicit constructor injection
    public TimePublisher(Properties properties)
    {
        //Request a default message Sender from corresponding strategy manager
        this.messageSender = MessageSenderManager.getMessageSender(properties);
    }

    @Override
    public void publish(LocalTime localTime)
    {
        // Send the message to the topic in JSON format.
        messageSender.send(localTime)
                .toTopic(TIME_TOPIC)
                .addHeader("Type", localTime.getClass().getSimpleName())
                .asJson();
    }
}
```

Typically, information stated in `jexxa-application.properties` for JMS are as follows: 

```properties
#suppress inspection "UnusedProperty" for whole file
#Settings for JMSAdapter and JMSSender
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://localhost:61616
java.naming.user=admin
java.naming.password=admin
```                       

## Implement the TimeListener
When receiving asynchronous messages we have to:
*   Define the connection information how to receive the data
*   Convert it into business data which is defined in the application core 
*   Forward it to a specific method within the application core. 
 
Implementing a port adapter for JMS using Jexxa is quite easy.
*   Within the constructor we define our class from the application core that will be called. Jexxa automatically 
    injects this object when creating the port adapter. By convention, this is the only object defined in the 
    constructor.  
*   In case of JMS we have to implement the JMS specific `MessageListener` interface. To facilitate this, Jexxa offers 
    convenience classes which perform JSON deserialization.
*   Finally, we have to pass the configuration parameter the specific driving adapter. In this case it is called 
    `JMSConfiguration` and allows to define all JMS related information, such as destination, messaging type, and a 
    messaging selector if required.

```java
@SuppressWarnings("unused")
public final class TimeListener extends TypedMessageListener<LocalTime> {
    private final TimeApplicationService timeApplicationService;
    private static final String TIME_TOPIC = "TimeService";

    //To implement a so called PortAdapter we need a public constructor which expects a single argument that must be a InboundPort.
    public TimeListener(TimeApplicationService timeApplicationService) {
        super(LocalTime.class);
        this.timeApplicationService = timeApplicationService;
    }

    @Override
    // The JMS specific configuration is defined via annotation.
    @JMSConfiguration(destination = TIME_TOPIC, messagingType = TOPIC)
    public void onMessage(LocalTime localTime) {
        // Forward this information to corresponding application service.
        timeApplicationService.displayPublishedTime(localTime);
    }
}
```

## Implement the Application ##

Finally, we have to write our application. As you can see in the code below, the only difference compared to `HelloJexxa`
is that we bind a JMSAdapter to our TimeListener

*   In case we use JMS, we connect JMSAdapter to the application specific port adapter.     
*   The rest of the main method is similar to `HelloJexxa` tutorial.   
   
```java
public final class TimeService
{
    public static void main(String[] args)
    {
        //Create your jexxaMain for this application
        var jexxaMain = new JexxaMain(TimeService.class);

        jexxaMain
                // Bind RESTfulRPCAdapter and JMXAdapter to TimeService class so that we can invoke its method
                .bind(RESTfulRPCAdapter.class).to(TimeApplicationService.class)
                .bind(RESTfulRPCAdapter.class).to(jexxaMain.getBoundedContext())
                .bind(JMSAdapter.class).to(PublishTimeListener.class)

                .run();
    }
}
```  

That's it. 

## Run the Application with console output ##

Disabling of all infrastructure components can be done by property files. By convention, Jexxa tries to find a real implementation of infrastructure components such as a database or messaging system. If they are not configured, Jexxa falls back to dummy implementation that are suitable for local testing.    

```console                                                          
mvn clean install
java -jar "-Dio.jexxa.config.import=./src/test/resources/jexxa-local.properties" \
     ./target/timeservice-jar-with-dependencies.jar
```
You will see following (or similar) output
```console
[main] INFO io.jexxa.utils.JexxaBanner - Config Information: 
[main] INFO io.jexxa.utils.JexxaBanner - Jexxa Version                  : VersionInfo[version=5.0.1-SNAPSHOT, repository=scm:git:https://github.com/jexxa-projects/Jexxa.git/jexxa-core, projectName=Jexxa-Core, buildTimestamp=2022-06-24 05:10]
[main] INFO io.jexxa.utils.JexxaBanner - Context Version                : VersionInfo[version=1.0.20-SNAPSHOT, repository=scm:git:https://github.com/jexxa-projects/JexxaTutorials.git/timeservice, projectName=TimeService, buildTimestamp=2022-06-24 16:53]
[main] INFO io.jexxa.utils.JexxaBanner - Used Driving Adapter           : [JMSAdapter, RESTfulRPCAdapter]
[main] INFO io.jexxa.utils.JexxaBanner - Used Properties Files          : [/jexxa-application.properties, ./src/test/resources/jexxa-local.properties]
[main] INFO io.jexxa.utils.JexxaBanner - Used Message Sender Strategie  : [MessageLogger]
[main] INFO io.jexxa.utils.JexxaBanner - 
[main] INFO io.jexxa.utils.JexxaBanner - Access Information: 
[main] INFO io.jexxa.utils.JexxaBanner - Listening on: http://0.0.0.0:7502
[main] INFO io.jexxa.utils.JexxaBanner - OpenAPI available at: http://0.0.0.0:7502/swagger-docs
[main] INFO io.jexxa.utils.JexxaBanner - JMS Listening on  : tcp://ActiveMQ:61616
[main] INFO io.jexxa.utils.JexxaBanner -    * JMS-Topics   : []
[main] INFO io.jexxa.utils.JexxaBanner -    * JMS-Queues   : []
[main] INFO io.jexxa.core.JexxaMain - BoundedContext 'TimeService' successfully started in 1.964 seconds


```          

### Publish the time  with console output

You can use curl to publish the time.  
```Console
curl -X POST http://localhost:7502/TimeApplicationService/publishTime
```

Each time you execute curl you should see following output on the console: 

```console                                                          
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Begin> Send message
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Message           : {"hour":17,"minute":12,"second":34,"nano":873658000}
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Destination       : TimeService
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Destination-Type  : TOPIC
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - End> Send message
```

## Run the Application with JMS
Running the application with a locally messaging system is typically required for testing and developing purpose. Therefore, we use the file [jexxa-test.properties](src/test/resources/jexxa-test.properties). 

```console                                                          
mvn clean install
java -jar "-Dio.jexxa.config.import=./src/test/resources/jexxa-test.properties" \
          ./target/timeservice-jar-with-dependencies.jar
```
You will see following (or similar) output
```console
...
[main] INFO io.jexxa.utils.JexxaBanner - Config Information: 
[main] INFO io.jexxa.utils.JexxaBanner - Jexxa Version                  : VersionInfo[version=5.0.1-SNAPSHOT, repository=scm:git:https://github.com/jexxa-projects/Jexxa.git/jexxa-core, projectName=Jexxa-Core, buildTimestamp=2022-06-24 05:10]
[main] INFO io.jexxa.utils.JexxaBanner - Context Version                : VersionInfo[version=1.0.20-SNAPSHOT, repository=scm:git:https://github.com/jexxa-projects/JexxaTutorials.git/timeservice, projectName=TimeService, buildTimestamp=2022-06-24 16:53]
[main] INFO io.jexxa.utils.JexxaBanner - Used Driving Adapter           : [JMSAdapter, RESTfulRPCAdapter]
[main] INFO io.jexxa.utils.JexxaBanner - Used Properties Files          : [/jexxa-application.properties, ./src/test/resources/jexxa-test.properties]
[main] INFO io.jexxa.utils.JexxaBanner - Used Message Sender Strategie  : [JMSSender]
[main] INFO io.jexxa.utils.JexxaBanner - 
[main] INFO io.jexxa.utils.JexxaBanner - Access Information: 
[main] INFO io.jexxa.utils.JexxaBanner - Listening on: http://0.0.0.0:7502
[main] INFO io.jexxa.utils.JexxaBanner - OpenAPI available at: http://0.0.0.0:7502/swagger-docs
[main] INFO io.jexxa.utils.JexxaBanner - JMS Listening on  : tcp://localhost:61616
[main] INFO io.jexxa.utils.JexxaBanner -    * JMS-Topics   : [TimeService]
[main] INFO io.jexxa.utils.JexxaBanner -    * JMS-Queues   : []
[main] INFO io.jexxa.core.JexxaMain - BoundedContext 'TimeService' successfully started in 2.223 seconds
... 
```          

As you can see in the last two lines, we now use the `JMSSender` which is listening on Topic TimeService. 

### Publish the time with JMS ###
 
You can use curl to publish the time.  
```Console
curl -X POST http://localhost:7502/TimeApplicationService/publishTime
```

Each time you execute curl you should see following output on the console: 

```console                                                          
[ActiveMQ Session Task-1] INFO io.jexxa.tutorials.timeservice.infrastructure.drivenadapter.display.MessageDisplayImpl - New Time was published, time: 17:15:18.743772
```
